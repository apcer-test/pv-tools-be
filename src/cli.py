from pathlib import Path
from typing import Dict, List, Optional

import uvicorn
from alembic import command
from alembic.config import Config
from alembic.util import AutogenerateDiffsDetected
from celery.apps.worker import Worker
from rich import print as pt
from rich.console import Console
from rich.panel import Panel
from rich.theme import Theme
from typer import Typer

from config import settings
from core.utils.celery_worker import celery_app
from core.utils.logging_config import init_default_logging

# Initialize logging
init_default_logging()

# Initialize rich console with custom theme
console = Console(
    theme=Theme(
        {
            "info": "cyan",
            "warning": "yellow",
            "error": "red",
            "success": "green",
            "highlight": "magenta bold",
            "header": "cyan bold",
            "file": "green",
            "directory": "blue",
            "progress": "green",
            "command": "yellow bold",
        }
    )
)


class ColoredOutput:
    """Helper class for colored terminal output"""

    @staticmethod
    def success(message: str) -> str:
        """
        Return a success message in green color.

        Args:
            message (str): The message to display.

        Returns:
            str: The formatted message with success color.
        """
        return f"[success]✅ {message}[/]"

    @staticmethod
    def info(message: str) -> str:
        """
        Return an info message in cyan color.

        Args:
            message (str): The message to display.

        Returns:
            str: The formatted message with info color.
        """
        return f"[info]ℹ️  {message}[/]"

    @staticmethod
    def warning(message: str) -> str:
        """
        Return a warning message in yellow color.

        Args:
            message (str): The message to display.

        Returns:
            str: The formatted message with warning color.
        """
        return f"[warning]⚠️  {message}[/]"

    @staticmethod
    def error(message: str) -> str:
        """
        Return an error message in red color.

        Args:
            message (str): The message to display.

        Returns:
            str: The formatted message with error color.
        """
        return f"[error]❌ {message}[/]"

    @staticmethod
    def highlight(message: str) -> str:
        """
        Return a highlighted message in magenta color.

        Args:
            message (str): The message to display.

        Returns:
            str: The formatted message with highlight color.
        """
        return f"[highlight]{message}[/]"

    @staticmethod
    def file_created(file_path: str) -> str:
        """
        Return a file created message in green color.

        Args:
            file_path (str): The path to the created file.

        Returns:
            str: The formatted message with file created color.
        """
        return f"[file]📄 Created file: [bold]{file_path}[/][/]"

    @staticmethod
    def directory_created(dir_path: str) -> str:
        """
        Return a directory created message in blue color.

        Args:
            dir_path (str): The path to the created directory.

        Returns:
            str: The formatted message with directory created color.
        """
        return f"[directory]📁 Created directory: [bold]{dir_path}[/][/]"

    @staticmethod
    def header(message: str) -> str:
        """
        Return a header message in cyan color.

        Args:
            message (str): The message to display.

        Returns:
            str: The formatted message with header color.
        """
        border = "═" * (len(message) + 4)
        return f"\n[header]{border}\n  {message.upper()}\n{border}[/]\n"

    @staticmethod
    def command_suggestion(command: str) -> str:
        """
        Return a command suggestion message in yellow color.

        Args:
            command (str): The command to display.

        Returns:
            str: The formatted message with command suggestion color.
        """
        return f"[command]🚀 To run: [success]{command}[/][/]"


class AppGenerator:
    """
    AppGenerator class for creating FastAPI application structures.

    This class provides methods to create the basic directory structure and
    generate the content for the application files.
    """

    def __init__(self, app_name: str):
        self.app_name = app_name
        self.base_path = Path("apps") / app_name

    def create_directory_structure(self) -> None:
        """Create the basic directory structure for the FastAPI application"""
        console.print(ColoredOutput.header("Creating Directory Structure"))

        directories = [
            self.base_path,
            self.base_path / "controllers",
            self.base_path / "schemas",
            self.base_path / "services",
            self.base_path / "models",
        ]

        for directory in directories:
            directory.mkdir(parents=True, exist_ok=True)
            console.print(ColoredOutput.directory_created(str(directory)))

    def get_file_contents(self) -> Dict[Path, str]:
        """Generate the content for all application files"""
        files_content = {
            self.base_path / "__init__.py": "",
            self.base_path
            / "controllers"
            / "__init__.py": self.get_controller_init_content(),
            self.base_path
            / "controllers"
            / f"{self.app_name}.py": self.get_controller_content(),
            self.base_path / "schemas" / "__init__.py": "",
            self.base_path
            / "schemas"
            / "request.py": self.get_schema_content_request(),
            self.base_path
            / "schemas"
            / "response.py": self.get_schema_content_response(),
            self.base_path / "services" / "__init__.py": "",
            self.base_path
            / "services"
            / f"{self.app_name}.py": self.get_services_content(),
            self.base_path / "models" / "__init__.py": "",
            self.base_path / "models" / f"{self.app_name}.py": self.get_model_content(),
            self.base_path / "exception.py": self.get_exception_content(),
            self.base_path / "models" / "__init__.py": self.get_model_init_content(),
            self.base_path / "schemas" / "__init__.py": self.get_schema_init_content(),
            self.base_path
            / "services"
            / "__init__.py": self.get_service_init_content(),
        }

        return files_content

    def get_controller_content(self) -> str:
        """
        Return the content for the controller file.

        Returns:
            str: The content for the controller file.
        """
        return """from typing import Annotated, List
from uuid import UUID
from fastapi import APIRouter, Body, Depends, status

from {app_name}.schemas import (
    CreateRequest,
    UpdateRequest,
    SampleResponse,
)
from {app_name}.services import {app_name}Service
from {app_name}.models import {app_name}Model

router = APIRouter(prefix="/api/v1/{app_name}", tags=["{app_name}"])

# Create your routes here

""".format(
            app_name=self.app_name
        )

    def get_services_content(self) -> str:
        """
        Return the content for the services file.

        Returns:
            str: The content for the services file.
        """
        return '''import json
from typing import Annotated, List
from uuid import UUID

from fastapi import Depends, Request
from sqlalchemy import and_, or_, select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import load_only

import constants
from apps.{app_name}.models import {app_name}Model
from apps.{app_name}.schemas import (CreateRequest, UpdateRequest, SampleResponse)

from core.db import db_session




class {app_name}Service:
    """
    Service with methods to handle {app_name} authentication and information.

    This service provides methods for creating {app_name}, logging in, and retrieving {app_name} information.
    """

    def __init__(self, session: Annotated[AsyncSession, Depends(db_session)]) -> None:
        """
        Initialize {app_name}Service with a database session
        This method also calls a database connection which is injected here.

        Args:
            session (AsyncSession): An asynchronous database connection.
        """
        self.session = session

    #create your services here 

'''.format(
            app_name=self.app_name
        )

    def get_schema_content_request(self) -> str:
        """
        Return the content for the request schema file.

        Returns:
            str: The content for the request schema file.
        """
        return """from pydantic import BaseModel, Field, model_validator
from typing import Optional
from core.utils import CamelCaseModel


class CreateRequest(CamelCaseModel):
    pass

class UpdateRequest(CamelCaseModel):
    pass
"""

    def get_schema_content_response(self) -> str:
        """
        Return the content for the response schema file.

        Returns:
            str: The content for the response schema file.
        """
        return """from pydantic import BaseModel
from datetime import datetime
from typing import Optional, List
from core.utils import BaseResponse

class SampleResponse(BaseResponse):
    pass

"""

    def get_model_content(self) -> str:
        """
        Return the content for the model file.

        Returns:
            str: The content for the model file.
        """
        return """import uuid
from typing import Self

from sqlalchemy.orm import Mapped, mapped_column

from core.db import Base
from core.utils.mixins import TimeStampMixin, UUIDPrimaryKeyMixin

class {app_name}Model(Base, UUIDPrimaryKeyMixin, TimeStampMixin):
    #define your model fields here
    pass

""".format(
            app_name=self.app_name
        )

    def get_controller_init_content(self) -> str:
        """
        Return the content for the controller init file.

        Returns:
            str: The content for the controller init file.
        """
        return """from src.apps.{app_name}.controllers.{app_name} import router as {app_name}_router

__all__ = ["{app_name}_router"]""".format(
            app_name=self.app_name
        )

    def get_model_init_content(self) -> str:
        """
        Return the content for the model init file.

        Returns:
            str: The content for the model init file.
        """
        return """from src.apps.{app_name}.models.{app_name} import {app_name}Model

__all__ = ["{app_name}Model"]""".format(
            app_name=self.app_name
        )

    def get_schema_init_content(self) -> str:
        """
        Return the content for the schema init file.

        Returns:
            str: The content for the schema init file.
        """
        return """from src.apps.{app_name}.schemas.request import CreateRequest, UpdateRequest
from src.apps.{app_name}.schemas.response import SampleResponse

__all__ = ["CreateRequest", "UpdateRequest", "SampleResponse"]""".format(
            app_name=self.app_name
        )

    def get_service_init_content(self) -> str:
        """
        Return the content for the service init file.

        Returns:
            str: The content for the service init file.
        """
        return """from src.apps.{app_name}.services.{app_name} import {app_name}Service

__all__ = ["{app_name}Service"]""".format(
            app_name=self.app_name
        )

    def get_exception_content(self) -> str:
        """
        Return the content for the exception file.

        Returns:
            str: The content for the exception file.
        """
        return """import constants
from core.exceptions import CustomException, NotFoundError, UnauthorizedError, UnprocessableEntityError, BadRequestError

#create your custom exception class here
"""

    def show_summary(self) -> None:
        """Display a beautiful summary of the created app"""
        console.print(ColoredOutput.header("FastAPI App Generation Complete"))

        console.print(
            ColoredOutput.success(
                f"Successfully created FastAPI app '{self.app_name}'!"
            )
        )
        console.print(
            ColoredOutput.info(f"App structure created at: {self.base_path.absolute()}")
        )

        # Show directory structure
        console.print("\n[header]📂 Directory Structure:[/]")
        structure_lines = [
            f"src/apps/{self.app_name}/",
            "├── controllers/",
            "│   ├── __init__.py",
            f"│   └── {self.app_name}.py",
            "├── schemas/",
            "│   ├── __init__.py",
            "│   ├── request.py",
            "│   └── response.py",
            "├── services/",
            "│   ├── __init__.py",
            f"│   └── {self.app_name}.py",
            "├── models/",
            "│   ├── __init__.py",
            f"│   └── {self.app_name}.py",
            "├── __init__.py",
            "└── exception.py",
        ]

        for line in structure_lines:
            if "├──" in line or "└──" in line:
                console.print(f"[directory]{line}[/]")
            elif "│" in line:
                console.print(f"[directory]{line}[/]")
            else:
                console.print(f"[bold]{line}[/]")

        # Show next steps
        console.print("\n[command]🚀 Next Steps:[/]")
        console.print(
            ColoredOutput.info(
                "1. Include your models in src/apps/__init__.py (before migrating your models)"
            )
        )
        console.print(
            ColoredOutput.info(
                "2. Include your app's router in src/apps/server.py (before running your server)"
            )
        )
        console.print(ColoredOutput.info("Your FastAPI application is ready to use!"))


cli = Typer(pretty_exceptions_show_locals=False)
alembic_cfg = Config()
alembic_cfg.set_main_option("script_location", "migrations")
alembic_cfg.set_main_option("sqlalchemy.url", settings.DATABASE_URL)
alembic_cfg.set_main_option("compare_type", "true")
alembic_cfg.set_main_option(
    "file_template", "%%(year)d-%%(month).2d-%%(day).2d-%%(hour).2d_%%(minute).2d"
)


@cli.command(help="Create a new FastAPI application structure")
def startapp(app_name: str, verbose: bool = False) -> None:
    """Create a new FastAPI application structure"""
    try:
        app_path = Path("src/apps") / app_name
        if app_path.exists():
            console.print(
                ColoredOutput.error(f"Directory '{app_name}' already exists!")
            )
            return

        # Welcome message
        console.print(ColoredOutput.header("FastAPI App Generator"))
        console.print(
            ColoredOutput.info(
                f"Creating new FastAPI application: {ColoredOutput.highlight(app_name)}"
            )
        )

        generator = AppGenerator(app_name)
        generator.create_directory_structure()

        # Create files with progress indication
        console.print(ColoredOutput.header("Creating Application Files"))

        files_content = generator.get_file_contents()
        total_files = len(files_content)

        for i, (file_path, content) in enumerate(files_content.items(), 1):
            file_path.write_text(content)
            if verbose:
                console.print(ColoredOutput.file_created(str(file_path)))
            else:
                # Show progress
                progress = f"[{i}/{total_files}]"
                console.print(f"[progress]{progress}[/] [file]{file_path.name}[/]")

        # Show final summary
        generator.show_summary()

    except Exception as e:
        console.print(ColoredOutput.error(f"An error occurred: {str(e)}"))


@cli.command(
    help="""
    Detect database changes and create migrations.
    Make sure to import all the model classes to the apps.models.__init__.py file to detect all the changes.
    """
)
def make_migrations(message: Optional[str] = None) -> None:
    """
    Detects and generates database migrations.

    :param message: Optional message to include with the migration.
    """
    console.print(Panel.fit("[warning]Detecting new migrations![/warning]"))
    try:
        command.check(alembic_cfg)
        console.print(Panel.fit("[success]No changes detected![/success]"))
    except AutogenerateDiffsDetected:
        console.print(
            Panel.fit("[warning]Changes detected! Generating migrations.[/warning]")
        )
        command.revision(alembic_cfg, message=message, autogenerate=True)


@cli.command(help="Migrate the database")
def migrate() -> None:
    """
    Migrates the database to the latest version.
    """
    console.print(Panel.fit("[warning]Migrating database![/warning]"))
    command.upgrade(alembic_cfg, "head")


@cli.command(help="Rollback the database by one migration")
def rollback() -> None:
    """
    Rollbacks the database by one migration.
    """
    console.print(Panel.fit("[warning]Rolling back the database![/warning]"))
    command.downgrade(alembic_cfg, "-1")


@cli.command(help="Run the server")
def run(
    host: Optional[str] = None,
    port: Optional[int] = None,
    debug: Optional[bool] = False,
) -> None:
    """
    Run the server.
    """
    if not host:
        host = settings.APP_HOST
    if not port:
        port = settings.APP_PORT
    if debug or settings.APP_DEBUG:
        console.print(Panel.fit("[warning]Running in debug mode![/warning]"))
        uvicorn.run(
            "apps.server:debug_app",
            host=host,
            port=port,
            reload=not settings.APP_CONTAINER,
            reload_dirs=None if settings.APP_CONTAINER else ["src"],
            log_level="debug",
            use_colors=True,
            root_path="/" if settings.APP_CONTAINER else "",
        )
    else:
        console.print(Panel.fit("[warning]Running in production mode![/warning]"))
        uvicorn.run("apps.server:production_app", host=host, port=port)


@cli.command(help="Create multiple FastAPI application structures at once")
def startapps(app_names: List[str], verbose: bool = False) -> None:
    """Create multiple FastAPI application structures at once."""
    for app_name in app_names:
        console.print(f"[command]Creating app: [highlight]{app_name}[/]")
        startapp(app_name, verbose)


@cli.command(help="Run the worker")
def worker() -> None:
    """Initialize and start a background worker process.

    The worker is responsible for processing tasks from specified queues using Celery's
    background executor. It handles task execution with configured concurrency and logging settings.

    Configuration:
        - Uses specified queue(s) for task processing
        - Sets log level based on configuration
        - Configures concurrency level for parallel processing
        - Enables task event monitoring
        - Uses 'solo' pool in debug mode, 'prefork' pool otherwise

    Returns:
        None
    """
    pt(Panel.fit("[bold yellow]Starting worker![/bold yellow]"))
    _worker: Worker = celery_app.Worker(
        queues="main-queue",
        loglevel="INFO",
        logfile="logs/application.log",
        task_events=True,
        pool="prefork",
        autoscale="5,0",
    )
    _worker.start()
